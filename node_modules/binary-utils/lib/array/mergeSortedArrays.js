"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (arr1, arr2) {
    var getter1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (x) {
        return x;
    };
    var getter2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (x) {
        return x;
    };
    var deduplication = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    /**
     * compare element using getter
     * @param a
     * @param b
     * @returns {number}
     *   0  -> equal
     *   1  -> `a` bigger than `b`
     *   -1 -> `b` bigger than `a`
     */
    var compare = function compare(a, b) {
        var valA = getter1(a);
        var valB = getter2(b);

        if (valA > valB) {
            return 1;
        }

        if (valA < valB) {
            return -1;
        }

        return 0;
    };

    // clone so that does not change arguments
    var a1Clone = arr1.slice(0);
    var a2Clone = arr2.slice(0);

    var result = [];

    // loop until both array is empty
    while (a1Clone.length > 0 || a2Clone.length > 0) {
        var a1Head = a1Clone[0];
        var a2Head = a2Clone[0];

        if (!a1Head) {
            result = result.concat(a2Clone);
            break; // break if one of the array is empty
        }

        if (!a2Head) {
            result = result.concat(a1Clone);
            break; // break if one of the array is empty
        }

        var last = result.length > 0 && result[result.length - 1];
        var toAdd = void 0;
        switch (compare(a1Head, a2Head)) {
            case 0:
                {
                    if (deduplication) a2Clone.shift();
                    toAdd = a1Clone.shift();
                    break;
                }
            // a2Head is smaller
            case 1:
                {
                    toAdd = a2Clone.shift();
                    break;
                }
            // a1Head is smaller
            case -1:
                {
                    toAdd = a1Clone.shift();
                    break;
                }
            default: // impossible
        }

        // if dedup is true, do not append same element
        if (deduplication && last && getter1(last) === getter2(toAdd)) {
            break;
        }
        result.push(toAdd);
    }

    return result;
};